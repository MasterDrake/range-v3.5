///////////////////////////////////////////////////////////////////////////////
// Copyright (c) Electronic Arts Inc. All rights reserved.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// This file defines random number generation like the std C++ <random> header.
///////////////////////////////////////////////////////////////////////////////

#ifndef EASTL_RANDOM_H
#define EASTL_RANDOM_H

#if defined(EA_PRAGMA_ONCE_SUPPORTED)
#pragma once
#endif

#include <EASTL/internal/config.h>
#include <EASTL/numeric_limits.h>
#include <EASTL/random_number_generator.h>

///////////////////////////////////////////////////////////////////////////////
// min/max workaround
//
// MSVC++ has #defines for min/max which collide with the min/max algorithm
// declarations. The following may still not completely resolve some kinds of
// problems with MSVC++ #defines, though it deals with most cases in production
// game code.
//
#if EASTL_NOMINMAX
#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif
#endif

namespace eastl
{
    using default_random_engine = RNG<>;

    // TODO: 2)No idea on where to begin;
    class random_device;

    // Implements a uniform distribution of values generated by a Generator,
    // where Generator is typically a random or pseudo-random number generator.
    // Note that the min/max range for this class is inclusive, so if you want
    // random integers 0, 1, 2, and 3, then you need to init this class with (0, 3)
    // and not (0, 4).
    // See the C++11 Standard, section 26.5.1.6
    template<class IntType = int>
    class uniform_int_distribution
    {
        static_assert(eastl::is_integral<IntType>::value,
                      "uniform_int_distribution: IntType must be integral.");

    public:
        typedef IntType result_type;

        // For uniform_int_distribution, param_type defines simply the min and max values
        // of the range returned by operator(). It may mean something else for other
        // distribution types.
        struct param_type
        {
            explicit param_type(IntType a = 0,
                                IntType b = eastl::numeric_limits<IntType>::max());

            result_type a() const;
            result_type b() const;

            bool operator==(const param_type & x)
            {
                return (x.mA == mA) && (x.mB == mB);
            }
            bool operator!=(const param_type & x)
            {
                return (x.mA != mA) || (x.mB != mB);
            }

        protected:
            IntType mA;
            IntType mB;
        };

        uniform_int_distribution(IntType a = 0,
                                 IntType b = eastl::numeric_limits<IntType>::max());
        uniform_int_distribution(const param_type & params);

        void reset();

        template<class Generator>
        result_type operator()(Generator & g) const;

        template<class Generator>
        result_type operator()(Generator & g, const param_type & params) const;

        result_type a() const;
        result_type b() const;

        param_type param() const;
        void param(const param_type & params);

        result_type min() const;
        result_type max() const;

    protected:
        param_type mParam;
    };

    ///////////////////////////////////////////////////////////////////////
    // uniform_int_distribution
    ///////////////////////////////////////////////////////////////////////

    template<class IntType>
    inline uniform_int_distribution<IntType>::param_type::param_type(IntType aValue,
                                                                     IntType bValue)
      : mA(aValue)
      , mB(bValue)
    {
        EASTL_ASSERT(aValue <= bValue);
    }

    template<class IntType>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::param_type::a() const
    {
        return mA;
    }

    template<class IntType>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::param_type::b() const
    {
        return mB;
    }

    template<class IntType>
    inline uniform_int_distribution<IntType>::uniform_int_distribution(IntType aValue,
                                                                       IntType bValue)
      : mParam(aValue, bValue)
    {
        // Nothing more to do.
    }

    template<class IntType>
    inline uniform_int_distribution<IntType>::uniform_int_distribution(
        const param_type & params)
      : mParam(params)
    {
        // Nothing more to do.
    }

    template<class IntType>
    void uniform_int_distribution<IntType>::reset()
    {
        // Nothing to do.
    }

    template<class IntType>
    template<class Generator>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::operator()(Generator & g) const
    {
        return operator()(g, mParam);
    }

    template<class IntType>
    template<class Generator>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::operator()(Generator & g,
                                                  const param_type & params) const
    {
        // TODO:3) This code is taken from Conclusions here
        // https://www.pcg-random.org/posts/bounded-rands.html
        // TODO:3) Maybe we should use xoshiro or something like that. Tehcnically we
        // should do like Eric Niebler and put the license on top besides the real
        // license.txt
        //static_assert(sizeof(typename Generator::result_type) == 4, "Int distribution generator result_type should be at least 4 bytes.");
        const auto range = params.b() - params.a();
        uint32_t x = g();
        uint64_t m = uint64_t(x) * uint64_t(range);
        uint32_t l = uint32_t(m);
        if(l < range)
        {
            uint32_t t = -range;
            if(t >= range)
            {
                t -= range;
                if(t >= range)
                    t %= range;
            }
            while(l < t)
            {
                x = g();
                m = uint64_t(x) * uint64_t(range);
                l = uint32_t(m);
            }
        }
        return m >> 32;
    }

    template<class IntType>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::a() const
    {
        return mParam.mA;
    }

    template<class IntType>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::b() const
    {
        return mParam.mB;
    }

    template<class IntType>
    inline typename uniform_int_distribution<IntType>::param_type
    uniform_int_distribution<IntType>::param() const
    {
        return mParam;
    }

    template<class IntType>
    inline void uniform_int_distribution<IntType>::param(const param_type & params)
    {
        mParam = params;
    }

    template<class IntType>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::min() const
    {
        return mParam.mA;
    }

    template<class IntType>
    inline typename uniform_int_distribution<IntType>::result_type
    uniform_int_distribution<IntType>::max() const
    {
        return mParam.mB;
    }

    template<class ResultType>
    inline bool operator==(const uniform_int_distribution<ResultType> & lhs,
                           const uniform_int_distribution<ResultType> & rhs)
    {
        return (lhs.param() == rhs.param());
    }

    template<class ResultType>
    inline bool operator!=(const uniform_int_distribution<ResultType> & lhs,
                           const uniform_int_distribution<ResultType> & rhs)
    {
        return (lhs.param() != rhs.param());
    }

    // EASTL doesn't currently implement IO stream-related functionality.
    // It may be useful to forward declare these templates and let the user implement them
    // in the meantime.
    //
    // template<class CharT, class Traits, class ResultType>
    // eastl::basic_ostream<CharT, Traits>& operator<<(eastl::basic_ostream<CharT,
    // Traits>& os, const uniform_int_distribution& uid);
    //
    // template<class CharT, class Traits, class ResultType>
    // eastl::basic_istream<CharT, Traits>& operator>>(eastl::basic_istream<CharT,
    // Traits>& is, uniform_int_distribution& uid);

    // Implements a uniform eral distribution of values generated by a Generator,
    // where Generator is typically a random or pseudo-random number generator.
    // Note that the min/max range for this class is inclusive, so if you want
    // random reals 0.0, 1.1, 1.2, and 3.0, then you need to init this class with
    // (0.0, 3.0) and not (0.0, 4.0). See the C++11 Standard, section 26.5.1.6
    template<class RealType = double>
    class uniform_real_distribution
    {
        static_assert(eastl::is_floating_point_v<RealType>,
                      "uniform_real_distribution: RealType must be floating point.");

    public:
        typedef RealType result_type;

        // For uniform_real_distribution, param_type defines simply the min and max values
        // of the range returned by operator(). It may mean something else for other
        // distribution types.
        struct param_type
        {
            explicit param_type(RealType a = 0,
                                RealType b = eastl::numeric_limits<RealType>::max());

            result_type a() const;
            result_type b() const;

            bool operator==(const param_type & x)
            {
                return (x.mA == mA) && (x.mB == mB);
            }
            bool operator!=(const param_type & x)
            {
                return (x.mA != mA) || (x.mB != mB);
            }

        protected:
            RealType mA;
            RealType mB;
        };

        uniform_real_distribution(RealType a = 0,
                                  RealType b = eastl::numeric_limits<RealType>::max());
        uniform_real_distribution(const param_type & params);

        void reset();

        template<class Generator>
        result_type operator()(Generator & g) const;

        template<class Generator>
        result_type operator()(Generator & g, const param_type & params) const;

        result_type a() const;
        result_type b() const;

        param_type param() const;
        void param(const param_type & params);

        result_type min() const;
        result_type max() const;

    protected:
        param_type mParam;
    };

    ///////////////////////////////////////////////////////////////////////
    // uniform_real_distribution
    ///////////////////////////////////////////////////////////////////////

    template<class RealType>
    inline uniform_real_distribution<RealType>::param_type::param_type(RealType aValue,
                                                                       RealType bValue)
      : mA(aValue)
      , mB(bValue)
    {
        EASTL_ASSERT(aValue <= bValue);
    }

    template<class RealType>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::param_type::a() const
    {
        return mA;
    }

    template<class RealType>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::param_type::b() const
    {
        return mB;
    }

    template<class RealType>
    inline uniform_real_distribution<RealType>::uniform_real_distribution(RealType aValue,
                                                                          RealType bValue)
      : mParam(aValue, bValue)
    {
        // Nothing more to do.
    }

    template<class RealType>
    inline uniform_real_distribution<RealType>::uniform_real_distribution(
        const param_type & params)
      : mParam(params)
    {
        // Nothing more to do.
    }

    template<class RealType>
    void uniform_real_distribution<RealType>::reset()
    {
        // Nothing to do.
    }

    template<class RealType>
    template<class Generator>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::operator()(Generator & g) const
    {
        return operator()(g, mParam);
    }

    template<class RealType>
    template<class Generator>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::operator()(Generator & g,
                                                    const param_type & params) const
    {
        static_assert(sizeof(typename Generator::result_type) == 8,
                      "Generator result type should be at least 8 bytes.");
        // TODO:https://prng.di.unimi.it/#remarks#Generating uniform doubles in the unit
        // interval
        //TODO: This won't work on linux 
        //return params.a() + (g() >> 11) * 0x1.0p-53 * (params.b() - params.a());
        return 0;
    }

    template<class RealType>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::a() const
    {
        return mParam.mA;
    }

    template<class RealType>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::b() const
    {
        return mParam.mB;
    }

    template<class RealType>
    inline typename uniform_real_distribution<RealType>::param_type
    uniform_real_distribution<RealType>::param() const
    {
        return mParam;
    }

    template<class RealType>
    inline void uniform_real_distribution<RealType>::param(const param_type & params)
    {
        mParam = params;
    }

    template<class RealType>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::min() const
    {
        return mParam.mA;
    }

    template<class RealType>
    inline typename uniform_real_distribution<RealType>::result_type
    uniform_real_distribution<RealType>::max() const
    {
        return mParam.mB;
    }

    template<class ResultType>
    inline bool operator==(const uniform_real_distribution<ResultType> & lhs,
                           const uniform_real_distribution<ResultType> & rhs)
    {
        return (lhs.param() == rhs.param());
    }

    template<class ResultType>
    inline bool operator!=(const uniform_real_distribution<ResultType> & lhs,
                           const uniform_real_distribution<ResultType> & rhs)
    {
        return (lhs.param() != rhs.param());
    }

    // EASTL doesn't currently implement IO stream-related functionality.
    // It may be useful to forward declare these templates and let the user implement them
    // in the meantime.
    //
    // template<class CharT, class Traits, class ResultType>
    // eastl::basic_ostream<CharT, Traits>& operator<<(eastl::basic_ostream<CharT,
    // Traits>& os, const uniform_real_distribution& uid);
    //
    // template<class CharT, class Traits, class ResultType>
    // eastl::basic_istream<CharT, Traits>& operator>>(eastl::basic_istream<CharT,
    // Traits>& is, uniform_real_distribution& uid);
} // namespace eastl

// TODO: including this breaks everything, fix it :/ #include
// <EASTL/internal/random/discrete-distribution.hpp>

#endif // Header include guard